---
title: "Untitled"
output: html_document
---


## Utility Code
```{r, echo = FALSE}


pref_glm_use = pref_p_glm
# pref_glm_use = met_p_glm

smallt_glm_use = smallt_p_glm
# smallt_glm_use = met_smallt_p_glm

############ Modeling All the different Models

fun_optim_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,5,0.01)
    ut = rep(0,length(times))
    for (t in times){
      ut[count] = (alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.2,5,0.01)
    ut = rep(0,length(times))
    for (t in times){
      ut[count] = (alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}


#================  Net Metabolics ==========================

a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

fun.1 <- function(t) a*t+b*(2.47^c)/(t^(d-1))
fun.2 <- function(t) a*t+b*(3.8^c)/(t^(d-1))
fun.3 <- function(t) a*t+b*(4.7^c)/(t^(d-1))
fun.4 <- function(t) a*t+b*(6.1^c)/(t^(d-1))

met_net_dur = c(optimize(fun.1,interval=c(0,2))$minimum,
                optimize(fun.2,interval=c(0,2))$minimum,
                optimize(fun.3,interval=c(0,2))$minimum,
                optimize(fun.4,interval=c(0,4))$minimum)

#================  Gross Metabolics ==========================


a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

fun.1 <- function(t) a*t+b*(2.47^c)/(t^(d-1))
fun.2 <- function(t) a*t+b*(3.8^c)/(t^(d-1))
fun.3 <- function(t) a*t+b*(4.7^c)/(t^(d-1))
fun.4 <- function(t) a*t+b*(6.1^c)/(t^(d-1))

met_gross_dur = c(optimize(fun.1,interval=c(0,2))$minimum,
                  optimize(fun.2,interval=c(0,2))$minimum,
                  optimize(fun.3,interval=c(0,2))$minimum,
                  optimize(fun.4,interval=c(0,4))$minimum)

#================  Utility ==========================
masses = c(2.47,3.8,4.7,6.1)
mvttimes_pref = aggregate(movedur~condition,prefdata,mean)$movedur
rxtimes_pref = aggregate(reaction_tanv~condition,prefdata,mean)$reaction_tanv
p_alpha_pref = inv.logit(predict(pref_glm_use,data.frame(movedur=mvttimes_pref,eff_mass=masses)))

mvttimes_smallt = aggregate(movedur~condition,smalltdata,mean)$movedur
rxtimes_smallt = aggregate(reaction_tanv~eff_mass,smalltdata,mean)$reaction_tanv
p_alpha_smallt_gross = inv.logit(predict(smallt_glm_use,data.frame(movedur=mvttimes_smallt,eff_mass=masses)))

mvttimes_pilot = aggregate(movedur~condition,pilotdata,mean)$movedur
mvttimes_pilot_se = aggregate(movedur~condition,pilotdata,sd)$movedur/sqrt(8)
miss_angle_sd_pilot = aggregate(absmissangle ~ eff_mass, pilotdata,'sd')$absmissangle
rxtimes_pilot = aggregate(reaction_tanv~eff_mass,smalltdata,mean)$reaction_tanv

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

alpha_utility_gross=optimize(fun_optim_prx,
                             masses = masses,
                             mvttimes = mvttimes_pref,
                             p_alpha  = c(1,1,1,1),
                             rxtimes = c(1,1,1,1),
                             interval=c(-100,300))
util_dur_gross = as.numeric(fun_dur_prx(alpha_utility_gross$minimum,
                                        masses = masses,
                                        mvttimes = mvttimes_pref,
                                        p_alpha  = c(1,1,1,1),
                                        rxtimes = c(1,1,1,1)))

a0 = mean(mpdata$metpowerrest)
a0_sd = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

alpha_utility_net=optimize(fun_optim_prx,
                           masses = masses,
                           mvttimes = mvttimes_pref,
                           p_alpha  = c(1,1,1,1),
                           rxtimes = c(1,1,1,1),
                           interval=c(-100,300))
util_dur_net = as.numeric(fun_dur_prx(alpha_utility_gross$minimum,
                                      masses = masses,
                                      mvttimes = mvttimes_pref,
                                      p_alpha  = c(1,1,1,1),
                                      rxtimes = c(1,1,1,1)))

#================  Utility with reaction times and P(alpha) ==========================

fun_optim_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  times = seq(0.3,2,0.001)
  ut = matrix(,nrow = length(mvttimes),ncol = length(times))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    for (t in times){
      ut[k, count] = (alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut[k,])]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

fun_optim_prx_logit <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = inv.logit(predict(p_alpha,data.frame(movedur=t,eff_mass=m)))
    rt = rxtimes[k]
    times = seq(0.5,2,0.001)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    count = 1
    for (t in times){
      ut[count] = (alpha*probs[count]-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
    # print(max(ut))
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

## Gross Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

# Using given probabilities
alpha_utility_gross_rx = optimize(fun_optim_prx,
                                  masses = masses,
                                  mvttimes = mvttimes_pref,
                                  p_alpha  = p_alpha_pref,
                                  rxtimes = rxtimes_pref,
                                  opt_or_dur = 'optimize',
                                  interval=c(-100,300))

util_dur_gross_rx = as.numeric(fun_optim_prx(alpha_utility_gross_rx$minimum,
                                       masses     = masses,
                                       mvttimes   = mvttimes_pref,
                                       p_alpha    = p_alpha_pref,
                                       opt_or_dur = 'duration',
                                       rxtimes    = rxtimes_pref))

# Using logit function
alpha_utility_gross_rx = optimize(fun_optim_prx_logit,
                                  masses     = masses,
                                  mvttimes   = mvttimes_pref,
                                  p_alpha    = pref_glm_use,
                                  rxtimes    = rxtimes_pref,
                                  opt_or_dur = 'optimize',
                                  interval   = c(-100,300))

util_dur_gross_rx = as.numeric(fun_optim_prx_logit(
                                       alpha      = alpha_utility_gross_rx$minimum,
                                       masses     = masses,
                                       mvttimes   = mvttimes_pref,
                                       p_alpha    = pref_glm_use,
                                       opt_or_dur = 'duration',
                                       rxtimes    = rxtimes_pref))

## Net Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

# Using given probabilities
alpha_utility_net_rx = optimize(fun_optim_prx,
                                masses = masses,
                                mvttimes = mvttimes_pref,
                                p_alpha  = p_alpha_pref,
                                opt_or_dur = 'optimize',
                                rxtimes = rxtimes_pref,
                                interval=c(-100,300))
util_dur_net_rx = as.numeric(fun_optim_prx(alpha_utility_net_rx$minimum,
                                        masses = masses,
                                        mvttimes = mvttimes_pref,
                                        p_alpha  = p_alpha_pref,
                                        opt_or_dur = 'duration',
                                        rxtimes = rxtimes_pref))

# Using logit function
alpha_utility_net_rx = optimize(fun_optim_prx_logit,
                                masses = masses,
                                mvttimes = mvttimes_pref,
                                p_alpha  = pref_glm_use,
                                opt_or_dur = 'optimize',
                                rxtimes = rxtimes_pref,
                                interval=c(-100,300))
util_dur_net_rx = as.numeric(fun_optim_prx_logit(alpha_utility_net_rx$minimum,
                                        masses = masses,
                                        mvttimes = mvttimes_pref,
                                        p_alpha  = pref_glm_use,
                                        opt_or_dur = 'duration',
                                        rxtimes = rxtimes_pref))

#================  M = 1 ==========================

# a=coef(MPNet_model)[1]
# b=coef(MPNet_model)[2]
# c=coef(MPNet_model)[3]
# d=coef(MPNet_model)[4]

a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

c=1

m1_dur = as.numeric(c(optimize(fun.1,interval=c(0,10))$minimum,
                      optimize(fun.2,interval=c(0,10))$minimum,
                      optimize(fun.3,interval=c(0,10))$minimum,
                      optimize(fun.4,interval=c(0,10))$minimum))

#================  M = 2 ==========================
c=2

m2_dur = as.numeric(c(optimize(fun.1,interval=c(0,2))$minimum,
                      optimize(fun.2,interval=c(0,2))$minimum,
                      optimize(fun.3,interval=c(0,2))$minimum,
                      optimize(fun.4,interval=c(0,4))$minimum))



#================  Torque Squared =========================

fun_optim_torque_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,2,0.01)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*probs[t_count]-a0*rt-(0*t+b_torque*(m^c_torque)/(t^(d_torque-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_torque_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.2,2,0.01)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*probs[t_count]-a0*rt-(0*t+b_torque*(m^c_torque)/(t^(d_torque-1))))/(rt+t)
      count = count+1
    }
    # plot(ut)
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}

fun_optim_torque_prx2 <- function(alpha,masses,mvttimes,probs,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = probs[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,2,0.01)
    ut = rep(0,length(times))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*p-a0*rt-(0*t+b_torque*(m^c_torque)/(t^(d_torque-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_torque_prx2 <- function(alpha,masses,mvttimes,probs,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    rt = rxtimes[k]
    p = probs[k]
    count = 1
    times = seq(0.2,2,0.01)
    ut = rep(0,length(times))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*p-a0*rt-(0*t+b_torque*(m^c_torque)/(t^(d_torque-1))))/(rt+t)
      count = count+1
    }
    # plot(ut)
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]

alpha_torque_2a=optimize(fun_optim_torque_prx,
                                masses = masses,
                                mvttimes = mvttimes_pref,
                                p_alpha  = pref_glm_use,
                                rxtimes = rxtimes_pref,
                                interval=c(-100,300))$minimum

torque_dur_2a = as.numeric(fun_dur_torque_prx(alpha_torque_2a,
                                        masses = masses,
                                        mvttimes = mvttimes_pref,
                                        p_alpha  = pref_glm_use,
                                        rxtimes = rxtimes_pref))

alpha_torque_2b=optimize(fun_optim_torque_prx,
                                masses = masses,
                                mvttimes = mvttimes_smallt,
                                p_alpha  = smallt_glm_use,
                                rxtimes = rxtimes_smallt,
                                interval=c(-100,300))$minimum

torque_dur_2b = as.numeric(fun_dur_torque_prx(alpha_torque_2b,
                                        masses = masses,
                                        mvttimes = mvttimes_smallt,
                                        p_alpha  = smallt_glm_use,
                                        rxtimes = rxtimes_smallt))

alpha_torque_2c=optimize(fun_optim_torque_prx2,
                                masses = masses,
                                mvttimes = mvttimes_pilot,
                                probs  = c(1,1,1,1),
                                rxtimes = rxtimes_pilot,
                                interval=c(-100,300))$minimum

torque_dur_2c = as.numeric(fun_dur_torque_prx2(alpha_torque_2c,
                                        masses = masses,
                                        mvttimes = mvttimes_pilot,
                                        probs  = c(1,1,1,1),
                                        rxtimes = rxtimes_pilot))


#================  Torque Squared Min Jerk =========================

fun_optim_torque_prx_mj <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,3,0.01)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*probs[t_count]-coef(MPGross_model)[1]*rt-(0*t+b_torque_mj*(m^c_torque_mj)/(t^(d_torque_mj-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_torque_prx_mj <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,3,0.01)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*probs[t_count]-coef(MPGross_model)[1]*rt-(0*t+b_torque_mj*(m^c_torque_mj)/(t^(d_torque_mj-1))))/(rt+t)
      count = count+1
    }
    # plot(ut)
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}

fun_optim_torque_prx_mj2 <- function(alpha,masses,mvttimes,probs,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = probs[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,3,0.01)
    ut = rep(0,length(times))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*p-a0*rt-(0*t+b_torque_mj*(m^c_torque_mj)/(t^(d_torque_mj-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_torque_prx_mj2 <- function(alpha,masses,mvttimes,probs,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = probs[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,3,0.01)
    ut = rep(0,length(times))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*p-a0*rt-(0*t+b_torque_mj*(m^c_torque_mj)/(t^(d_torque_mj-1))))/(rt+t)
      count = count+1
    }
    # plot(ut)
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}


a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]

alpha_torque_2a_mj=optimize(fun_optim_torque_prx_mj,
                                masses = masses,
                                mvttimes = mvttimes_pref,
                                p_alpha  = pref_glm_use,
                                rxtimes = rxtimes_pref,
                                interval=c(-100,300))$minimum

torque_mj_dur_2a = as.numeric(fun_dur_torque_prx_mj(alpha_torque_2a_mj,
                                        masses = masses,
                                        mvttimes = mvttimes_pref,
                                        p_alpha  = pref_glm_use,
                                        rxtimes = rxtimes_pref))

alpha_torque_2b_mj=optimize(fun_optim_torque_prx_mj,
                                masses = masses,
                                mvttimes = mvttimes_smallt,
                                p_alpha  = smallt_glm_use,
                                rxtimes = rxtimes_smallt,
                                interval=c(-100,300))$minimum

torque_mj_dur_2b = as.numeric(fun_dur_torque_prx_mj(alpha_torque_2b_mj,
                                        masses = masses,
                                        mvttimes = mvttimes_smallt,
                                        p_alpha  = smallt_glm_use,
                                        rxtimes = rxtimes_smallt))

alpha_torque_2c_mj=optimize(fun_optim_torque_prx_mj2,
                                masses = masses,
                                mvttimes = mvttimes_pilot,
                                probs  = c(1,1,1,1),
                                rxtimes = rxtimes_pilot,
                                interval=c(-100,300))$minimum

torque_mj_dur_2c = as.numeric(fun_dur_torque_prx_mj2(alpha_torque_2c_mj,
                                        masses = masses,
                                        mvttimes = mvttimes_pilot,
                                        probs  = c(1,1,1,1),
                                        rxtimes = rxtimes_pilot))


#================ 2b and 2c utility modeling =========================

fun_p_alpha <- function(miss_dist, min_dist){
  p_alpha = c(0,0,0,0)
  count = 1
  for (k in miss_dist){
    p_alpha[count] = 2*(pnorm(min_dist, mean = 0, sd = k)-.5)
    count = count+1
  }
  return(p_alpha)
}
p_alpha_pilot_gross = fun_p_alpha(miss_angle_sd_pilot, 90)

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

alpha_smallt_gross = optimize(fun_optim_prx_logit,
                      masses     = masses,
                      mvttimes   = mvttimes_smallt,
                      p_alpha    = smallt_glm_use,
                      rxtimes    = rxtimes_smallt,
                      opt_or_dur = 'optimize',
                      interval   = c(-100,1000))

util_dur_smallt_gross = as.numeric(fun_optim_prx_logit(alpha_smallt_gross$minimum, #changing between alpha_pref and alpha_smallt_gross
                                     masses   = masses,
                                     mvttimes = mvttimes_smallt,
                                     p_alpha  = smallt_glm_use,
                                     rxtimes  = rxtimes_smallt,
                                     opt_or_dur = 'duration'))

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

alpha_smallt_net = optimize(fun_optim_prx_logit,
                      masses     = masses,
                      mvttimes   = mvttimes_smallt,
                      p_alpha    = smallt_glm_use,
                      rxtimes    = rxtimes_smallt,
                      opt_or_dur = 'optimize',
                      interval   = c(-100,1000))

util_dur_smallt_net = as.numeric(fun_optim_prx_logit(alpha_smallt_net$minimum, #changing between alpha_pref and alpha_smallt_gross
                                     masses   = masses,
                                     mvttimes = mvttimes_smallt,
                                     p_alpha  = smallt_glm_use,
                                     rxtimes  = rxtimes_smallt,
                                     opt_or_dur = 'duration'))

# Pilot stuff


a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

masses = c(2.47,3.8,4.7,6.1)

alpha_pilot_gross=optimize(fun_optim_prx,
                     masses   = masses,
                     mvttimes = mvttimes_pilot,
                     p_alpha  = p_alpha_pilot_gross,
                     rxtimes  = rxtimes_pilot,
                     opt_or_dur = 'optimize',
                     interval = c(-100,1000))

util_dur_pilot_gross = as.numeric(fun_optim_prx(alpha_pilot_gross$minimum,
                                    masses   = masses,
                                    mvttimes = mvttimes_pilot,
                                    p_alpha  = p_alpha_pilot_gross,
                                    rxtimes  = rxtimes_pilot,
                                    opt_or_dur = 'duration'))

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

alpha_pilot_net=optimize(fun_optim_prx,
                     masses   = masses,
                     mvttimes = mvttimes_pilot,
                     p_alpha  = p_alpha_pilot_gross,
                     rxtimes  = rxtimes_pilot,
                     opt_or_dur = 'optimize',
                     interval = c(-100,1000))

util_dur_pilot_net = as.numeric(fun_optim_prx(alpha_pilot_net$minimum,
                                    masses   = masses,
                                    mvttimes = mvttimes_pilot,
                                    p_alpha  = p_alpha_pilot_gross,
                                    rxtimes  = rxtimes_pilot,
                                    opt_or_dur = 'duration'))
```

### Combined utility code

```{r, echo = FALSE, warning = FALSE}

fun_optim_prx_comb <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,2,0.001)
    ut = rep(0,length(times))
    for (t in times){
      ut[count] = (alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

fun_optim_prx_logit_comb <- function(alpha,masses,mvttimes,glm1,glm2,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,2,0.001)
    ut = rep(0,length(times))
    if (k<5){
      probs = inv.logit(predict(glm1,data.frame(movedur=times,eff_mass=m)))
    } else {
      probs = inv.logit(predict(glm2,data.frame(movedur=times,eff_mass=m)))
    }
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*probs[t_count]-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}


modelsum = summary(MPGross_model)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

masses = c(2.47,3.8,4.7,6.1)
mvttimes_pref = aggregate(movedur~condition,prefdata,mean)$movedur
mvttimes_pref_se = aggregate(movedur~condition,prefdata,sd)$movedur/sqrt(8)
miss_dist_sd_pref = aggregate(miss_dist ~ eff_mass, prefdata,'sd')$miss_dist
rxtimes_pref = aggregate(reaction_tanv~eff_mass,prefdata,mean)$reaction_tanv

masses = c(2.47,3.8,4.7,6.1)
mvttimes_smallt = aggregate(movedur~condition,smalltdata,mean)$movedur
mvttimes_smallt_se = aggregate(movedur~condition,smalltdata,sd)$movedur/sqrt(8)
miss_dist_sd_smallt = aggregate(miss_dist ~ eff_mass, smalltdata,'sd')$miss_dist
rxtimes_smallt = aggregate(reaction_tanv~eff_mass,smalltdata,mean)$reaction_tanv


# Combined stuff
# Not using logit function
# alpha_pref_comb_gross=optimize(fun_optim_prx_comb,
#                       masses     = c(masses,masses),
#                       mvttimes   = c(mvttimes_pref,mvttimes_smallt),
#                       p_alpha    = c(p_alpha_pref,p_alpha_smallt_gross),
#                       rxtimes    = c(rxtimes_pref,rxtimes_smallt),
#                       opt_or_dur = 'optimize',
#                       interval   = c(-100,200))
# pref_glm_use smallt_glm_use

# COMBINED UTILITY Gross
# USING logit function
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]
alpha_pref_comb_gross=optimize(fun_optim_prx_logit_comb,
                      masses     = c(masses,masses),
                      mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                      glm1       = pref_glm_use,
                      glm2       = smallt_glm_use,
                      rxtimes    = c(rxtimes_pref,rxtimes_smallt),
                      opt_or_dur = 'optimize',
                      interval   = c(-100,200))

a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]
util_dur_pref_alpha_comb_gross = as.numeric(fun_optim_prx_logit_comb(alpha_pref_comb_gross$minimum,
                                       masses     = c(masses,masses),
                                       mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                                       glm1       = pref_glm_use,
                                       glm2       = smallt_glm_use,
                                       opt_or_dur = 'duration',
                                       rxtimes    = c(rxtimes_pref,rxtimes_smallt)))

# COMBINED UTILITY Net
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]


alpha_pref_comb_net=optimize(fun_optim_prx_logit_comb,
                      masses     = c(masses,masses),
                      mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                      glm1       = pref_glm_use,
                      glm2       = smallt_glm_use,
                      rxtimes    = c(rxtimes_pref,rxtimes_smallt),
                      opt_or_dur = 'optimize',
                      interval   = c(-100,200))

util_dur_pref_alpha_comb_net = as.numeric(fun_optim_prx_logit_comb(alpha_pref_comb_net$minimum,
                                       masses     = c(masses,masses),
                                       mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                                       glm1       = pref_glm_use,
                                       glm2       = smallt_glm_use,
                                       opt_or_dur = 'duration',
                                       rxtimes    = c(rxtimes_pref,rxtimes_smallt)))

# Pilot
# Gross
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]
util_dur_pilot_gross_alpha_comb_gross = as.numeric(fun_optim_prx_comb(
                                       alpha_pref_comb_gross$minimum,
                                       masses = masses,
                                       mvttimes = mvttimes_pilot,
                                       p_alpha  = c(1,1,1,1),
                                       opt_or_dur = 'duration',
                                       rxtimes = rxtimes_pilot))

p_alphas = data.frame('data_set' = c(rep('smallt',4),rep('pref',4),rep('pilot',4)),
                      'eff_mass' = cbind(rep(masses,3)),
                      'p_alpha'  = c(p_alpha_smallt_gross, p_alpha_pref, p_alpha_pilot_gross),
                      'movedur'  = c(mvttimes_smallt,mvttimes_pref, mvttimes_pilot),
                      'expnum'   = c(rep(3,4),rep(1,4),rep(2,4)))

p_alphas$expnum = as.factor(p_alphas$expnum)
p_alpha_plot <- ggplot()+
  geom_line(data=p_alphas,aes(x=movedur,y=p_alpha,color=expnum),size=3)+
  labs(x='Movement Duration (s)',
       y='Probability of Success')+
  scale_color_manual(labels = c('Circle\n(Normal)','None\n(Large)','Arc\n(Small)'),values = gg_color_hue(3))+
  theme_classic()+
  theme(text              = element_text(size=15,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=12),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  guides(color=guide_legend(override.aes = list(size = 7),
                            title="Target type\n(size)",
                            keyheight=.5,
                            default.unit='inch'))

# setwd(pref_plots_dir)
# if (save_plots){ggsave(filename='p_alpha_plot.pdf',plot=p_alpha_plot,height=4,width=6,useDingbats=FALSE)}

```

## Table for the coefficients in Utility Modeling
We next fitted a utility model by altering $\alpha$ to try and predict the movement durations seen in 2a,b,c.

The utility function that is fit for these next plots is below.
$T_r$ and $T_m$ are the reaction time and movement duration.
$P(R|m,t)$ is determined from the section above, probability alpha modeling. $a$, $b$, $c$, $d$ are determined from the metabolic data.
Resting rate is shown by $a_0$, and $a_0$ = `r round(mean(mpdata_rest),3)`.
The parameters a, b, c, and d are shown in \@ref(tab:effortmodtab).

$$J = \frac{\alpha P(R|m,T_m) -\left( a_0 T_r + a T_m + \frac{bm^c}{T_m^d} \right)}{T_r+T_m}$$
Ideally the probability function has an effect of mass in it, but for the following results we use the glm from experiement 2a/2b to fit $\alpha$, which leads to the probability function only including a term of time.

$$J = \frac{\alpha P(R|T_m) -\left( a_0 T_r + a T_m + \frac{bm^c}{T_m^d} \right)}{T_r+T_m}$$

$T_r$ and $T_m$ are the reaction time and movement duration. Using the values from experiment 2a,b,c, we can optimize the error of the prediction by altering $\alpha$.

The tables below show the movement durations (\@ref{tab:utilmovedurstab}), reaction time (\@ref{rab:utilreacttimestab}).

```{r, echo = FALSE, warnings = FALSE}

movedurs = cbind(round(aggregate(movedur~eff_mass,prefdata,mean)$movedur,3),
                 round(aggregate(movedur~eff_mass,smalltdata,mean)$movedur,3),
                 round(aggregate(movedur~eff_mass,pilotdata,mean)$movedur,3))
colnames(movedurs) = c('2a','2b','2c')
rownames(movedurs) = c('2.47 kg','3.80 kg','4.70 kg','6.10 kg')


reacttimes = cbind(round(aggregate(reaction_tanv~eff_mass,prefdata,mean)$reaction_tanv,3),
                   round(aggregate(reaction_tanv~eff_mass,smalltdata,mean)$reaction_tanv,3),
                   round(aggregate(reaction_tanv~eff_mass,pilotdata,mean)$reaction_tanv,3))
colnames(reacttimes) = c('2a','2b','2c')
rownames(reacttimes) = c('2.47 kg','3.80 kg','4.70 kg','6.10 kg')

```

```{r utilmovedurstab, echo = FALSE, warning = FALSE, message = FALSE}
kable(movedurs, caption = 'Movement durations by experiement and effective mass used in the Utility model')
```

```{r utilreacttimestab, echo = FALSE, warnigns = FALSE}
kable(reacttimes, caption = 'Reaction times by experiement and effective mass used in the Utility model')
```

## Experimental Utility Fits
### 2a Alpha

Table (\@ref(tab:utildurs2a)) shows the fitted values for alpha given the specific utility model and the parameters fit previously. These are only for experiment 2a.

```{r , echo = FALSE, warning = FALSE, message = FALSE}
tab1 = cbind(c(round(alpha_utility_net_rx$minimum,4)),
             c(round(alpha_utility_gross_rx$minimum,4)),
             c(round(alpha_torque_2a,4)),
             c(round(alpha_torque_2a_mj,4)))
# rownames(tab1) = c('a0','a','b','c','d','$\\alpha$')
rownames(tab1) = c('$\\alpha$')
colnames(tab1) = c('Net Metabolics', 'Gross Metabolics','Torque$^2$','Torque$^2$ minjerk')

tab2 = cbind(c(0,
               round(aggregate(movedur ~ eff_mass,prefdata,mean)$movedur,4),
               0),
             c(0,
               round(met_net_dur,4),
               formatC(sum((met_net_dur-mvttimes_pref)^2),format = 'e', digits = 3)),
             c(0,
               round(met_gross_dur,4),
               formatC(sum((met_gross_dur-mvttimes_pref)^2),format = 'e', digits = 3)),
             c(round(alpha_utility_net_rx$minimum,4),
               round(util_dur_net_rx,4),
               formatC(sum((util_dur_net_rx-mvttimes_pref)^2),format = 'e', digits = 3)),
             c(round(alpha_utility_gross_rx$minimum,4),
               round(util_dur_gross_rx,4),
               formatC(sum((util_dur_gross_rx-mvttimes_pref)^2),format = 'e', digits = 3)),
             c(round(alpha_torque_2a,4),
               round(torque_dur_2a,4),
               formatC(sum((torque_dur_2a-mvttimes_pref)^2),format = 'e', digits = 3)),
             c(round(alpha_torque_2a_mj,4),
               round(torque_mj_dur_2a,4),
               formatC(sum((torque_mj_dur_2a-mvttimes_pref)^2),format = 'e', digits = 3)))
rownames(tab2) = c('Alpha','2.47','4.73','6.99','11.50','SSE')
colnames(tab2) = c('2a Experiment','Net Metabolic Power','Gross Metabolic power','Utility (Net Power)', 'Utility (Gross Power','Torque$^2$','Torque$^2$ minjerk')

```

<!-- ```{r utilcoefftabs, echo = FALSE, warning = FALSE, message = FALSE} -->
<!--   kable(tab1, caption = 'Parameters used in the Utility modeling') -->
<!-- ``` -->

This table (\@ref(tab:utildurs2a)) shows the $\alpha$ value, predicted durations for the models, and the SSE between that and the experimental data. The SSE for all these models is shown in detail later (section \@ref{SSE2a}).

```{r utildurs2a, echo = FALSE, warning = FALSE, message = FALSE}
  kable(tab2, caption = 'Preferred duration and predicted durations for each model.')
```

The probability of success for utility in experiement 2a using the optimized alpha value are shown below.

```{r optprobstab2a, echo = FALSE, warning = FALSE, message = FALSE}
  
opt_probs = cbind(inv.logit(predict(pref_glm_use,data.frame(movedur=util_dur_net_rx,eff_mass=masses))),
                  inv.logit(predict(pref_glm_use,data.frame(movedur=util_dur_gross_rx,eff_mass=masses))),
                  inv.logit(predict(pref_glm_use,data.frame(movedur=torque_dur_2a,eff_mass=masses))),
                  inv.logit(predict(pref_glm_use,data.frame(movedur=torque_mj_dur_2a,eff_mass=masses))))

rownames(opt_probs) = masses
colnames(opt_probs) = c('Utility Net','Utility Gross','Utility Torque','Utility Torque Mj')

kable(opt_probs, caption = 'Probability of success used in utility modeling when fitting alpha, Expirement 2a.')
```


### 2b Alpha

Table (\@ref(tab:utildurs2b)) shows the fitted values for alpha given the specific utility model and the parameters fit previously. These are only for experiment 2b.

```{r , echo = FALSE, warning = FALSE, message = FALSE}
tab1 = cbind(c(round(alpha_smallt_net$minimum,4)),
             c(round(alpha_smallt_gross$minimum,4)),
             c(round(alpha_torque_2b,4)),
             c(round(alpha_torque_2b_mj,4)))
# rownames(tab1) = c('a0','a','b','c','d','$\\alpha$')
rownames(tab1) = c('$\\alpha$')
colnames(tab1) = c('Net Metabolics', 'Gross Metabolics','Torque$^2$','Torque$^2$ minjerk')

tab2 = cbind(c(0,
               round(mvttimes_smallt,4),
               0),
             c(0,
               round(met_net_dur,4),
               formatC(sum((met_net_dur-mvttimes_smallt)^2),format = 'e', digits = 3)),
             c(0,
               round(met_gross_dur,4),
               formatC(sum((met_gross_dur-mvttimes_smallt)^2),format = 'e', digits = 3)),
             c(round(alpha_smallt_net$minimum,4),
               round(util_dur_smallt_net,4),
               formatC(sum((util_dur_smallt_net-mvttimes_smallt)^2),format = 'e', digits = 3)),
             c(round(alpha_smallt_gross$minimum,4),
               round(util_dur_smallt_gross,4),
               formatC(sum((util_dur_smallt_gross-mvttimes_smallt)^2),format = 'e', digits = 3)),
             c(round(alpha_torque_2b,4),
               round(torque_dur_2b,4),
               formatC(sum((torque_dur_2b-mvttimes_smallt)^2),format = 'e', digits = 3)),
             c(round(alpha_torque_2b_mj,4),
               round(torque_mj_dur_2b,4),
               formatC(sum((torque_mj_dur_2b-mvttimes_smallt)^2),format = 'e', digits = 3)))
rownames(tab2) = c('Alpha','2.47','4.73','6.99','11.50','SSE')
colnames(tab2) = c('2b Experiment','Net Metabolic Power','Gross Metabolic power','Utility (Net Power)', 'Utility (Gross Power','Torque$^2$','Torque$^2$ minjerk')

```

This table (\@ref(tab:utildurs2a)) shows the $\alpha$ value, predicted durations for the models, and the SSE between that and the experimental data. The SSE for all these models is shown in detail later (section \@ref{SSE2b}).

```{r utildurs2b, echo = FALSE, warning = FALSE, message = FALSE}
  kable(tab2, caption = 'Preferred duration and predicted durations for each model.')
```

The probability of success for utility in experiement 2b using the optimized alpha value are shown below.

```{r optprobstab2b, echo = FALSE, warning = FALSE, message = FALSE}
  
opt_probs = cbind(inv.logit(predict(smallt_glm_use,data.frame(movedur=util_dur_smallt_net,eff_mass=masses))),
                  inv.logit(predict(smallt_glm_use,data.frame(movedur=util_dur_smallt_gross,eff_mass=masses))),
                  inv.logit(predict(smallt_glm_use,data.frame(movedur=torque_dur_2b,eff_mass=masses))),
                  inv.logit(predict(smallt_glm_use,data.frame(movedur=torque_mj_dur_2b,eff_mass=masses))))

rownames(opt_probs) = masses
colnames(opt_probs) = c('Utility Net','Utility Gross','Utility Torque','Utility Torque Mj')

kable(opt_probs, caption = 'Probability of success used in utility modeling when fitting alpha, Expirement 2b.')
```


### 2c Alpha

Table (\@ref(tab:utildurs2c)) shows the fitted values for alpha given the specific utility model and the parameters fit previously. These are only for experiment 2c.

```{r , echo = FALSE, warning = FALSE, message = FALSE}
tab1 = cbind(c(round(alpha_pilot_net$minimum,4)),
             c(round(alpha_pilot_gross$minimum,4)),
             c(round(alpha_torque_2c,4)),
             c(round(alpha_torque_2c_mj,4)))
# rownames(tab1) = c('a0','a','b','c','d','$\\alpha$')
rownames(tab1) = c('$\\alpha$')
colnames(tab1) = c('Net Metabolics', 'Gross Metabolics','Torque$^2$','Torque$^2$ minjerk')

tab2 = cbind(c(0,
               round(mvttimes_pilot,4),
               0),
             
             c(0,
               round(met_net_dur,4),
               formatC(sum((met_net_dur-mvttimes_pilot)^2),format = 'e', digits = 3)),
             
             c(0,
               round(met_gross_dur,4),
               formatC(sum((met_gross_dur-mvttimes_pilot)^2),format = 'e', digits = 3)),
             
             c(round(alpha_pilot_net$minimum,4),
               round(util_dur_pilot_net,4),
               formatC(sum((util_dur_pilot_net-mvttimes_pilot)^2),format = 'e', digits = 3)),
             
             c(round(alpha_pilot_gross$minimum,4),
               round(util_dur_pilot_gross,4),
               formatC(sum((util_dur_pilot_gross-mvttimes_pilot)^2),format = 'e', digits = 3)),
             
             c(round(alpha_torque_2c,4),
               round(torque_dur_2c,4),
               formatC(sum((torque_dur_2c-mvttimes_pilot)^2),format = 'e', digits = 3)),
             
             c(round(alpha_torque_2c_mj,4),
               round(torque_mj_dur_2c,4),
               formatC(sum((torque_mj_dur_2c-mvttimes_pilot)^2),format = 'e', digits = 3)))
rownames(tab2) = c('Alpha','2.47','4.73','6.99','11.50','SSE')
colnames(tab2) = c('2c Experiment','Net Metabolic Power','Gross Metabolic power','Utility (Net Power)', 'Utility (Gross Power','Torque$^2$','Torque$^2$ minjerk')

```


This table (\@ref(tab:utildurs2c)) shows the $\alpha$ value, predicted durations for the models, and the SSE between that and the experimental data. The SSE for all these models is shown in detail later (section \@ref{SSE2b}).

```{r utildurs2c, echo = FALSE, warning = FALSE, message = FALSE}
  kable(tab2, caption = 'Preferred duration and predicted durations for each model.')
```

The probability of success for utility in experiement 2b using the optimized alpha value are shown below.

```{r optprobstab2c, echo = FALSE, warning = FALSE, message = FALSE}
  
opt_probs = cbind(c(1,1,1,1),
                  c(1,1,1,1),
                  c(1,1,1,1),
                  c(1,1,1,1))

rownames(opt_probs) = masses
colnames(opt_probs) = c('Utility Net','Utility Gross','Utility Torque','Utility Torque Mj')

kable(opt_probs, caption = 'Probability of success used in utility modeling when fitting alpha, Expirement 2c.')
```


<!-- ### Alpha from 2a predicting 2b -->
<!-- This table shows the predicted movement durations of 2b using the alpha values from 2a. -->
<!-- ```{r ,echo = FALSE, warning = FALSE} -->
<!-- masses = c(2.47,3.8,4.7,6.1) -->
<!-- mvttimes = aggregate(movedur~condition,prefdata,mean)$movedur -->
<!-- rxtimes = aggregate(reaction_tanv~condition,prefdata,mean)$reaction_tanv -->

<!-- mvttimes_smallt = aggregate(movedur~condition,smalltdata,mean)$movedur -->
<!-- rxtimes_smallt = aggregate(reaction_tanv~eff_mass,smalltdata,mean)$reaction_tanv -->

<!-- a0 = mean(mpdata$metpowerrest) -->
<!-- a0_se = sd(mpdata$metpowerrest)/sqrt(8) -->
<!-- a=coef(MPGross_model)[1] -->
<!-- b=coef(MPGross_model)[2]*100 -->
<!-- c=coef(MPGross_model)[3] -->
<!-- d=coef(MPGross_model)[4] -->

<!-- util_2b_from_2a = optimize(fun_optim_prx_logit, -->
<!--                            masses = masses, -->
<!--                            mvttimes = mvttimes, -->
<!--                            p_alpha  = pref_glm_use, -->
<!--                            rxtimes = rxtimes, -->
<!--                            opt_or_dur = 'optimize', -->
<!--                            interval=c(-100,300)) -->

<!-- util_dur_2b_from_2a = as.numeric(fun_optim_prx_logit(util_2b_from_2a$minimum, -->
<!--                                        masses = masses, -->
<!--                                        mvttimes = mvttimes_smallt, -->
<!--                                        p_alpha  = smallt_glm_use, -->
<!--                                        opt_or_dur = 'duration', -->
<!--                                        rxtimes = rxtimes_smallt)) -->

<!-- tab = round(cbind(mvttimes_smallt,util_dur_2b_from_2a),3) -->
<!-- rownames(tab) = masses -->
<!-- colnames(tab) = c('2b Move Dur','Predicted 2b using 2a alpha') -->
<!-- ``` -->

<!-- ```{r 2bfrom2atab, echo = FALSE, warning = FALSE,  tab.cap = 'Predicted movement durations for experiment 2b using the alpha from 2a and the probabilities from 2b.'} -->
<!-- kable(tab, caption = paste('Predicted movement durations for experiment 2b using the alpha from 2a and the probabilities from 2b. SSE = ',round(sum(tab[,1]-tab[,2])^2,4),sep='')) -->
<!-- ``` -->


## 2a and 2b Combined Utility fits
This section analysis fits one $\alpha$ value to experiment 2a and 2b at the same time.
These next tables show the movement durations, predicted movement durations, the fitted alpha values, and the probabilities of success.
The $\alpha$ value for 2a and 2b are fit at once, so it is the same. 2c has its own $\alpha$ value.

The $\alpha$ value fitted here is `r alpha_pref_comb_gross$minimum`.
The SSE for experiment 2a/2b when using one alpha is `r formatC(sum((mvttimes_pref -util_dur_pref_alpha_comb_gross[1:4])^2)+sum((mvttimes_smallt -util_dur_pref_alpha_comb_gross[5:8])^2),format = 'e', digits = 3)`.
The SSE for experiment 2c is `r formatC(sum((util_dur_pilot_gross-mvttimes_pilot)^2),format = 'e', digits = 3)`. 
The total SSE for all 3 is `r formatC(sum((mvttimes_pref -util_dur_pref_alpha_comb_gross[1:4])^2)+sum((mvttimes_smallt -util_dur_pref_alpha_comb_gross[5:8])^2)+sum((util_dur_pilot_gross-mvttimes_pilot)^2),format = 'e', digits = 3)`.


```{r, echo = FALSE, warning = FALSE}

comb_ut_probtab = cbind(round(inv.logit(predict(pref_glm_use,
                                                data.frame(movedur=util_dur_pref_alpha_comb_gross[1:4],eff_mass=masses))),4),
                        round(inv.logit(predict(smallt_glm_use,
                                                data.frame(movedur=util_dur_pref_alpha_comb_gross[5:8],eff_mass=masses))),4),
                        c(1,1,1,1))
colnames(comb_ut_probtab) = c('2a','2b','2c')
rownames(comb_ut_probtab) = unique(prefdata$eff_mass)

comb_ut_durtab = cbind(mvttimes_pref,
                       util_dur_pref_alpha_comb_gross[1:4],
                       mvttimes_smallt,
                       util_dur_pref_alpha_comb_gross[5:8],
                       mvttimes_pilot,
                       util_dur_pilot_gross)
colnames(comb_ut_durtab) = c('2a Exp','2a pred','2b Exp','2b pred','2c Exp','2c pred')
rownames(comb_ut_durtab) = unique(prefdata$eff_mass)

alph_tab = cbind(round(alpha_pref_comb_gross$minimum,3), round(alpha_pref_comb_gross$minimum,3), round(alpha_pilot_gross$minimum,3))
colnames(alph_tab) = c('2a','2b','2c')
rownames(alph_tab) = '\alpha'

```

```{r combutdurtab1, echo = FALSE, warning = FALSE, tab.cap = 'Experimental and predicted movement durations for the experiments.'}
kable(comb_ut_durtab, caption = 'Experimental and predicted movement durations for the experiments.')
```

```{r combutprobtab1, echo = FALSE, warning = FALSE, tab.cap = 'Probabilites of success for the experiments.'}
kable(comb_ut_probtab, caption = 'Probabilites of success for the experiments.')
```

```{r alphtab1, echo = FALSE, warning = FALSE, tab.cap = 'Alpha values fitted to experiment 2a/2b, and a seperate alpha for 2c.'}
kable(alph_tab, caption = 'Alpha values fitted to experiment 2a/2b, and a seperate alpha for 2c.')
```


```{r, echo = FALSE, warning = FALSE}

control_times = rbind(cbind(rep('smallt',4),rep('data',4),c(2.5,3.8,4.7,6.1),mvttimes_smallt,rep(3,4),mvttimes_smallt_se),
                      cbind(rep('pref',4),rep('data',4),c(2.5,3.8,4.7,6.1),mvttimes_pref,rep(1,4),mvttimes_pref_se),
                      cbind(rep('pilot',4),rep('data',4),c(2.5,3.8,4.7,6.1),mvttimes_pilot,rep(2,4),mvttimes_pilot_se),
                      
                      cbind(rep('smallt',4),rep('model',4),c(2.5,3.8,4.7,6.1),util_dur_pref_alpha_comb_gross[5:8],rep(3,4),rep(0,4)),
                      cbind(rep('pref',4),rep('model',4),c(2.5,3.8,4.7,6.1),util_dur_pref_alpha_comb_gross[1:4],rep(1,4),rep(0,4)),
                      cbind(rep('pilot',4),rep('model',4),c(2.5,3.8,4.7,6.1),util_dur_pilot_gross,rep(2,4),rep(0,4)))
                      # cbind(rep('pilot',4),rep('model',4),c(2.5,3.8,4.7,6.1),util_dur_pilot_gross_alpha_comb_gross,rep(2,4),rep(0,4)))
colnames(control_times) = c('exp','datatype','eff_mass','movedur','expnum','movedur_se')

control_times = as.data.frame(control_times)
control_times$movedur = as.numeric(as.character(control_times$movedur))
control_times$movedur_se = as.numeric(as.character(control_times$movedur_se))
control_times$eff_mass = as.numeric(as.character(control_times$eff_mass))

utilfits_by_exp <- ggplot()+
  geom_errorbar(data=control_times,
                aes(x=eff_mass,
                    ymin=movedur-movedur_se,
                    ymax=movedur+movedur_se,
                    color=expnum,
                    alpha=datatype),
                size=3,
                width=.2)+
  geom_line(data=control_times,
              aes(x=eff_mass,
                  y=movedur,
                  linetype=datatype,
                  color=expnum,
                  alpha = datatype),
              size=3)+
  geom_line(data=data.frame(cbind(unique(control_times$eff_mass),
                            util_dur_pilot_gross_alpha_comb_gross) %>% `colnames<-`(c('eff_mass','movedur'))),
            aes(x=eff_mass,
                y=movedur),
            linetype = 'dashed',
            color = 'black',
            size=3)+
  geom_line(data=data.frame(cbind(unique(control_times$eff_mass),
                                  met_gross_dur) %>% `colnames<-`(c('eff_mass','movedur'))),
            aes(x=eff_mass,
                y=movedur),
            linetype = 'dashed',
            color    = 'red',
            size=3)+
  scale_linetype_manual(values=c('solid','dashed'),
                        labels=c('Data (Solid)','Model (Dashed)'))+
  scale_alpha_discrete(range=c(.5,1),
                        labels=c('Data (Solid)','Model (Dashed)'))+
  labs(x='Effective mass (kg)',
       y='Movement Duration (s)',
       title = paste('Util fits by Experiment\n2a,2b \U1D6FC = ',
                     round(alpha_pref_comb_gross$minimum,3),
                     ', 2c \U1D6FC = ',
                     round(alpha_pilot_gross$minimum,3),
                     '\nBlack = prob equal 1, red = metgross min',sep=''))+
  scale_color_manual(labels = c('Circle\n(Normal)',
                                'None\n(Large)',
                                'Arc\n(Small)',
                                paste('\U1D6FC = ',round(alpha_pref_comb_gross$minimum,3),sep=''),
                                'Gross Met Min'),
                     values = c(gg_color_hue(3),
                                'black',
                                'red'))+
  scale_x_continuous(breaks = c(unique(control_times$eff_mass)))+
  theme_classic()+
  theme(text              = element_text(size=20,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=15),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  guides(color=guide_legend(override.aes = list(size = 7),
                            title="Target type\n(size)",
                            keyheight=.5,
                            default.unit='inch'),
         linetype = guide_legend(title="Data Type",
                           keyheight=.4,
                           default.unit='inch'),
         alpha = FALSE)

setwd(pref_plots_dir)
if (save_plots){ggsave(filename='utilfits_by_exp.pdf',plot=utilfits_by_exp,height=4,width=6,useDingbats=FALSE)}

theme_set(theme_cowplot(font_size=12))
exp_legend <- get_legend(utilfits_by_exp)

plots_to_fix = c('Movedur_by_experiment',
                 'Movedurnorm_by_experiment',
                 'utilfits_by_exp')

for (plot in plots_to_fix){
  string = paste(plot,'<-',plot,'+
                 theme_classic()+
                 theme(text              = element_text(color=\'black\'),
                 axis.text         = element_text(color=\'black\'),
                 axis.ticks        = element_line(color=\'black\'),
                 plot.title        = element_text(hjust = 0.5),
                 axis.line         = element_line(color=\'black\'),
                 legend.position   = \'none\')',sep = '')
  eval(parse(text = string))
}

grouped_utility_movedur <- plot_grid(plot_grid(Movedur_by_experiment+
                                                 labs(title = 'Movement Duration\nBy Experiment')+
                                                 theme(legend.position='none',
                                                       plot.title = element_text(hjust = 0.5),
                                                       text=element_text(size=16)),
                                               Movedurnorm_by_experiment+
                                                 labs(title = 'Normalized Movement Duration\nBy Experiment')+
                                                 theme(legend.position='none',
                                                       plot.title = element_text(hjust = 0.5),
                                                       text=element_text(size=16)),
                                               labels=c('A','B'),
                                               label_size = 24),
                                     plot_grid(utilfits_by_exp+
                                                 theme(text=element_text(size=16),
                                                       legend.position = 'none'),
                                               exp_legend,
                                               labels = c('C',''),
                                               label_size = 24,
                                               rel_widths = c(.8,.2)),
                                     nrow = 2,
                                     rel_heights = c(.4,.8))


setwd(pref_plots_dir)
if (save_plots){ggsave('grouped_utility_movedur.pdf',plot=grouped_utility_movedur,width=9/.8,height=9, useDingbats = FALSE)}

```

```{r groupedutilitymovedur1, echo = FALSE, warning = FALSE, fig.width=12, fig.height=9, fig.cap = 'Utility fits across experiments.'}
  grouped_utility_movedur
```
